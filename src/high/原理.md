为什么setState是异步？
我认为我们同意延迟对账以进行批量更新是有益的。也就是说，我们同意setState()在许多情况下同步重新渲染效率很低，如果我们知道我们可能会获得多个更新，那么批量更新会更好。
如果我们在浏览器中click处理，都Child和Parent调用setState，我们不想重新渲染Child两次，而是更愿意将它们标记为脏，以及它们放在一起退出浏览器事件之前重新呈现。
保证内部一致性
即使state是同步更新，props也不是。（props在重新渲染父组件之前，您无法知道，如果您同步执行此操作，则批处理会离开窗口


在同步模型中，this.state会立即刷新，但this.props不会。并且我们不能在this.props不重新渲染父级的情况下立即刷新，这意味着我们将不得不放弃批处理（根据具体情况，这会非常显着地降低性能）。


在反应，都this.state和this.props只有reconciliation和flushing后更新，所以你会看到0之前和之后重构正在打印。这使升降状态更安全。
React模型并不总是导致最简洁的代码，但它在内部是一致的，并确保提升状态是安全的



关于使用setTimeout会立即更新setState
只有在React事件处理程序中调用它时才进行异步批处理，​​否则它是同步的。调用setState的setTimeout，因此是同步。
React 当前在React管理的事件处理程序中批量更新，因为React“坐”在顶部调用堆栈框架并知道所有React事件处理程序何时运行。此时它会刷新更新。

如果React没有设置事件处理程序，则当前它使更新同步。因为它不知道是否可以安全等待，以及其他更新是否会很快发生。

在React的未来版本中，此行为将发生变化。计划是默认将更新视为低优先级，以便最终合并并批处理（例如在一秒内），并选择立即刷新它们